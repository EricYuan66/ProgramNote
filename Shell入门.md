1. Shell时一个**命令行解释器**，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序
2. Shell还是一个功能相当强大的**编程语言**，是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令
3. echo 命令输出颜色字符：echo -e "\e[1;*31m* 嫁人就要嫁凤姐 \e[0m"<br>
其中31m 表示红色，其他还有32m，33m等
4. 脚本执行<br>
    1. 赋予执行权限，直接通过脚本路径调用： ***./hello.sh***
    2. 通过Bash或者其他的sh 调用执行脚本： ***bash hello.sh***
5. **~/** 代表你的/home/用户名目录；**./** 是代表当前目录本身
6. **pwd** 命令来查看”当前工作目录“的完整路径
7. 别名
    1. alias #查看系统中所有的命令别名； 
    2. alias 别名= '原命令' #设置别名，重启失效
    3. 永久生效的别名需要写入环境变量配置文件： vi ~/.bashrc
    4. unalias 删除别名
8. 历史命令：history
9. Linux中一切接文件，标准输入输出设备也是文件
    |设备|设备文件名|文件描述符|类型|
    |:-:|:-:|:-:|:-:|
    |键盘|/dev/stdin|0|标准输入|
    |显示器|/dev/stdout|1|标准输出|
    |显示器|/dev/stderr|2|标准错误输出|
10. 输出重定向
    类型|符号|作用
    -|-|-
    **标准输出重定向**|命令 > 文件 / 命令 >> 文件|以覆盖/追加的方式，将命令的正确结果输出到指定的文件或设备中
    标准错误输出重定向|错误命令 2> 文件 / 错误命令 2>> 文件|以覆盖/追加的方式，将命令的错误结果输出到指定的文件或设备中
    **正确输出和错误输出同时重定向**|命令 &> 文件 / 命令 &>> 文件 / 命令 >> 文件 2>&1|以覆盖/追加的方式，将正确输出和错误输出都保存在同一个文件当中
    **正确输出和错误输出分别重定向**|命令 >> 文件1 2>> 文件2|以追加的方式，将正确输出到文件1，将错误输出到文件2当中
11. 输入重定向：使用较少
12. 多命令顺序执行
    多命令执行符|格式|作用
    -|-|-
    ;|命令1;命令2|多个命令顺序执行，命令之间没有任何逻辑关系
    &&|命令1&&命令2|逻辑与，当命令1正确执行，命令2才会执行，如果命令1执行不正确，命令2不会执行
    \|\||命令1\|\|命令2|逻辑或，如果命令1执行不正确，命令2才会执行，当命令1正确执行，则命令2不会执行
    
    + 命令 && echo yes || echo no 可以用来判断命令是否执行正确
13. **管道符**
    1. 命令1 | 命令2<br>
    *命令1的**正确输出**作为命令2的操作对象*
    2. 举例：查看服务器的连接数量<br>
    netstat -an | grep EXTABLISHED | wc -l
14. 通配符
    通配符|作用
    -|-
    ?|匹配一个任意字符
    *|匹配0个或任意多个字符
    []|匹配中括号中任意一个字符。例如[ABC]代表匹配A,或者匹配B，或者匹配C
    [-]|匹配中括号中任意一个字符，-代表一个范围：[a-z], [0-9]
    [^]|匹配不是中括号内的一个字符
15. **其他特殊字符**
    符号|作用
    -|-
    ''|在单引号中所有特殊字符都没有特殊含义
    ""|在双引号中特殊字符没有特殊含义，但是"$", "`", "\\"是例外
    ``|引用系统命令，会先执行它
    $()|和反引号作用一样，用来引用系统命令
    $|调用变量的值
    #|#开头的行代表注释
    \||转义符，跟在\之后的特殊符号将失去特殊含义变为普通字符
16. 在Bash中，变量的默认类型都是字符串型
17. 变量的分类
    + **用户自定义变量**
    + **环境变量**：这种变量中主要保存的是和系统操作环境相关的数据。变量可以自定义，但是**对系统生效的环境变量名和变量作用是固定的**，即一部分环境变量可以自定义，一部分是固定的
    + **位置参数变量**：主要用来向脚本传递参数或数据，变量名不能自定义，作用固定
    + **预定义变量**：是Bash中已经定义好的，变量名不能自定义，变量作用也是固定的；位置参数变量其实是一种特殊的预定义变量
18. 用户自定义变量
    1. 变量叠加
        + x="$x"456
    2. 变量查看
        + set 查看系统中所有正在运行的变量
        + set -u 如果设定此选项，调用未声明变量时会报错（默认无任何提示）
    3. 删除变量
        + unset 变量名
19. 环境变量
    1. 环境变量和自定义变量的最大区别：
        + 环境变量是全局变量，可以在当前shell和当前shell的子shell中看到
        + 自定义变量是局部变量，只能在当前shell中可见
    2. 设置环境变量
        + ecport 变量名=变量值
    3. 查看环境变量
        + set 查看所有变量
        + env 仅查看环境变量
        + unset 删除环境变量
    4. 系统定义的环境变量
        + **PATH**：系统查找命令的路径，用: 分割
        + PS1：命令提示符设置
        + LOCALHOST：主机名
        + SHELL：当前shell
        + TERM：终端环境
        + HISTSIZE：历史命令条数
        + SSH_CLIENT：当用ssh连接时记录客户端ip
        + SSH_TTY：ssh连接的终端时pts/1
        + USER：当前登陆用户
20. bash语系变量
    1. locale 定义当前系统主语系的变量
    2. linux安装时选择了中文语言，虽然系统界面无法显示中文，但是远程连接工具可以显示中文
21. 位置参数
    位置参数变量|作用
    -|-
    $n|n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，第十个以上的参数需要用大括号包含，如${10}
    $*|这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体，例如在for循环中只会循环一次
    $@|这个变量也代表命令行中所有的参数，不过$@把每个参数区别对待，例如在for循环中会循环位置参数数量的次数
    $#|这个变量代表命令行中所有参数的个数
22. 预定义变量
    位置参数变量|作用
    -|-
    $?|最后一次执行的命令的返回状态。如果上一个命令正确执行，则返回0；如果不正确执行，则返回非0值
    $$|当前进程的进程号(PID)
    $!|后台运行的最后一个进程的进程号
23. 接受键盘输入<br>
    read [选项] [变量名]
    - 选项
    - -p ：“提示信息”在等待read输入时，输出提示信息
    - -t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间
    - -n 字符数：read命令只接受指定的字符数，就会执行
    - -s ：隐藏输入的数据，适用于机密信息的输入
24. 声明变量类型
    1. linux变量默认都为字符串类型
    2. declare 声明变量类型
        - declare [+/-][选项] 变量名
        - 选项
        - \-：给变量设定类型属性
        - \+：取消变量的类型属性
        - -a：将变量声明为数组型（也可以直接使用 变量名[index] 声明数组）
        - -i：将变量声明为整数型（integer）
        - -x：将变量声明为环境变量（与export类似）
        - -r：将变量声明为只读变量
        - -p：显示指定变量的被声明的类型  
25.
| 表格      | 第一列     | 第二列     |
| --- | :-----------:  | :-----------: |
| 第一行     | 第一列     | 第二列     |
